import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as p,c as i,a as n,b as a,d as s,e as t}from"./app-e5581bd9.js";const c={},r=t('<h3 id="js基本数据类型" tabindex="-1"><a class="header-anchor" href="#js基本数据类型" aria-hidden="true">#</a> JS基本数据类型</h3><p><strong>7大数据类型</strong></p><ul><li>undefined、null、String、Number、Boolean、Symbol、（BigInt 【 ES10】） + Object【引用的】</li></ul><p><strong>两大细分</strong></p><ul><li><p>基本数据类型：number、string、null、undefined、boolean、symbol -- 栈</p></li><li><p>引用数据类型：object、array、function -- 堆</p></li></ul><p><strong>区别与特性</strong></p><ol><li>两种数据类型<strong>存储位置</strong>不同</li><li><strong>原始数据类型</strong>是直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据；</li><li><strong>引用数据类型</strong>存储在堆(heap)中的对象，占据空间大、大小不固定，如果存储在栈中，将会影响程序运行的性能；</li><li>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。</li><li>当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li></ol><h3 id="js中类型判断的哪些事" tabindex="-1"><a class="header-anchor" href="#js中类型判断的哪些事" aria-hidden="true">#</a> js中类型判断的哪些事？</h3>',8),d=n("li",null,[n("a",{href:""},"typeof")],-1),u={href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof",target:"_blank",rel:"noopener noreferrer"},h={href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString",target:"_blank",rel:"noopener noreferrer"},k=t(`<h3 id="和-的区别" tabindex="-1"><a class="header-anchor" href="#和-的区别" aria-hidden="true">#</a> == 和 === 的区别</h3><p><code>==</code> 先比较类型，类型不同先进行类型转换；再比较值；</p><p><code>===</code> 先比较类型，不同则返回false；类型相同才比较值。</p><h3 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h3><blockquote><p>闭包是指<code>有权访问另一个函数作用域中变量</code>的函数；</p><p>创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量；</p><p>利用闭包可以<code>突破作用域链</code>，将函数内部的变量和方法传递到外部。</p></blockquote><h6 id="feature" tabindex="-1"><a class="header-anchor" href="#feature" aria-hidden="true">#</a> feature</h6><ol><li>函数内再嵌套函数</li><li>内部函数可以引用外层的参数和变量</li><li>参数和变量<code>不会被垃圾回收机制回收</code></li></ol><h3 id="map和set的区别-es5与es6继承的区别" tabindex="-1"><a class="header-anchor" href="#map和set的区别-es5与es6继承的区别" aria-hidden="true">#</a> Map和Set的区别### ES5与ES6继承的区别</h3><ul><li><strong>思路</strong></li></ul><blockquote><p>ES5 的继承使用借助构造函数实现，实质是<code>先创造子类的实例对象this</code>，然后再将父类的方法添加到<code>this</code>上面。ES6 的继承机制完全不同，实质是<code>先创造父类的实例对象this</code>（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code> ;</p><p>ES6 在继承的语法上不仅继承了类的原型对象，还继承了类的静态属性和静态方法</p><p>...</p></blockquote><h3 id="对原生javascript的理解" tabindex="-1"><a class="header-anchor" href="#对原生javascript的理解" aria-hidden="true">#</a> 对原生JavaScript的理解</h3><ul><li>思路</li></ul><blockquote><p>JavaScript 实现包含的几个部分;</p><p>JavaScript 的语言类型特性;</p><p>解释性脚本语言（对标编译性脚本语言）;</p><p>面向对象（面向过程）;</p><p>事件驱动 / 异步 IO</p><p>自由...</p></blockquote><h3 id="null和undefined的区别" tabindex="-1"><a class="header-anchor" href="#null和undefined的区别" aria-hidden="true">#</a> null和undefined的区别</h3><ul><li><p><code>null</code>表示&quot;没有对象&quot;，即该处不应该有值。（是一个关键字，不能赋值）</p><p>典型用法是：</p><ul><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为对象原型链的终点。</li></ul></li><li><p><code>undefined</code>表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。（相当于一个变量，可以赋值）</p><p>典型用法是：</p><ul><li>变量被声明了，但没有赋值时，就等于undefined。</li><li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li><li>对象没有赋值的属性，该属性的值为undefined。</li><li>函数没有返回值时，默认返回undefined。</li></ul></li></ul><h3 id="箭头函数与普通函数的区别" tabindex="-1"><a class="header-anchor" href="#箭头函数与普通函数的区别" aria-hidden="true">#</a> 箭头函数与普通函数的区别</h3><ol><li><code>对this的关联</code>。内置this的值，取决于箭头函数在哪里定义，而非箭头函数执行的上下文环境。</li><li><code>new 不可用</code>。箭头函数不能用new关键字来实例化对象，否则报错。</li><li><code>this指向不会改变</code>。函数内置this指向不可改变，this在函数体内整个执行环境中为常量。有利于JavaScript引擎优化处理。</li><li><code>没有arguments对象</code>。不能通过arguments对象访问传入的实参。只能使用显示命名或者其它新特性完成。### void</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token number">0</span> <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token number">1</span> <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>name<span class="token operator">:</span> string<span class="token punctuation">,</span> <span class="token literal-property property">add</span><span class="token operator">:</span> string <span class="token operator">=</span> <span class="token string">&#39;湖南&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 
<span class="token comment">//解析为：</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> add</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>add <span class="token operator">===</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> add <span class="token operator">=</span> <span class="token string">&#39;湖南&#39;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// 注意：函数参数默认值的转换 </span>
  <span class="token comment">// if (typeof add === &#39;undefined&#39; ) { add = &#39;湖南&#39;; }</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong>： void 返回的都是 undefined 类型</p><h2 id="为什么-typeof-null-object" tabindex="-1"><a class="header-anchor" href="#为什么-typeof-null-object" aria-hidden="true">#</a> 为什么 <code>typeof null === &#39;object&#39;</code> ?</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// JavaScript 诞生以来便如此</span>
<span class="token keyword">typeof</span> <span class="token keyword">null</span> <span class="token operator">===</span> <span class="token string">&#39;object&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,21),f={href:"https://2ality.com/2013/10/typeof-null.html",target:"_blank",rel:"noopener noreferrer"},b=n("br",null,null,-1);function m(v,g){const e=l("ExternalLinkIcon");return p(),i("div",null,[r,n("ul",null,[d,n("li",null,[n("a",u,[a("instanceof"),s(e)])]),n("li",null,[n("a",h,[a("Object.prototype.toString.call(target)"),s(e)])])]),k,n("blockquote",null,[n("p",null,[a('在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，typeof null 也因此返回 "object"。（'),n("a",f,[a("参考来源"),s(e)]),a("）"),b,a(" 曾有一个 ECMAScript 的修复提案（通过选择性加入的方式），但被拒绝了。该提案会导致 typeof null === 'null'。")])])])}const j=o(c,[["render",m],["__file","Javascript.html.vue"]]);export{j as default};
