import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as t,c as n,a as l,b as e,d as o,e as s}from"./app-b5f1aaa9.js";const d={},h=l("blockquote",null,[l("p",null,"数据结构与算法课程内容包括数据结构与抽象数据类型、算法特性及分类、算法效率与度量、线性结构、顺序表、链表、栈与队列、栈与递归、递归转非递归、> 字符串的存储结构、字符串运算的算法实现、字符串的快速模式匹配、二叉树的抽象数据类型、二叉树的搜索、二叉树的存储结构、树与二叉树的等价转换、树> 的抽象数据类型及树的遍历、树的链式存储结构、树的父指针表示法、树的顺序存储和 K 叉树、图的概念和抽象数据类型、图的存储结构、图的遍历、内排> > 序、检索等内容。")],-1),c=l("h2",{id:"学习文档",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#学习文档","aria-hidden":"true"},"#"),e(" 学习文档")],-1),u={href:"https://algorithm-visualizer.org/",target:"_blank",rel:"noopener noreferrer"},_={href:"https://visualgo.net/zh",target:"_blank",rel:"noopener noreferrer"},p={href:"https://leetcode.cn/",target:"_blank",rel:"noopener noreferrer"},f=s('<h2 id="算法复杂度" tabindex="-1"><a class="header-anchor" href="#算法复杂度" aria-hidden="true">#</a> 算法复杂度</h2><blockquote><p>算法复杂度通常用来描述算法执行效率（时间复杂度）和所需存储资源（空间复杂度）。理解算法复杂度有助于我们评估算法在实际应用中的性能。</p></blockquote><h3 id="时间复杂度" tabindex="-1"><a class="header-anchor" href="#时间复杂度" aria-hidden="true">#</a> 时间复杂度</h3><p>时间复杂度是对算法执行时间的估计，描述了输入规模 <code>𝑛</code> 增大时，算法的运行时间如何变化。以下是常见的时间复杂度级别，从低到高：</p><ol><li>O(1) - 常数时间</li></ol><ul><li>运行时间与输入规模无关，直接输出结果。</li><li>示例：数组访问元素。</li></ul><ol start="2"><li>O(log𝑛) - 对数时间</li></ol><ul><li>每次操作将问题规模减小一半。</li><li>示例：二分查找。</li></ul><ol start="3"><li>O(n) - 线性时间</li></ol><ul><li>运行时间与输入规模成正比。</li><li>示例：遍历数组。</li></ul><ol start="4"><li>O(n·log𝑛) - 线性对数时间</li></ol><ul><li>常见于分治算法。</li><li>示例：快速排序、归并排序。</li></ul><ol start="5"><li>O(n^2) - 二次时间</li></ol><ul><li>双重循环中常见。</li><li>示例：冒泡排序、选择排序。</li></ul><ol start="6"><li>O(n^k) - 多项式时间</li></ol><ul><li><code>𝑘</code> k 次嵌套循环。</li><li>示例：矩阵乘法。</li></ul><ol start="7"><li>O(2^n) - 指数时间</li></ol><ul><li>常见于递归解决方案，枚举所有可能。</li><li>示例：解决子集问题、斐波那契数列（未优化）。</li></ul><ol start="8"><li>O(n!) - 阶乘时间</li></ol><ul><li>常见于排列问题。</li><li>示例：旅行商问题暴力解法。</li></ul><h3 id="空间复杂度" tabindex="-1"><a class="header-anchor" href="#空间复杂度" aria-hidden="true">#</a> 空间复杂度</h3><p>空间复杂度描述了算法运行时所需的额外存储空间，通常包括临时变量、递归栈等：</p><ol><li>O(1) - 常数空间：不依赖输入规模，使用固定空间。</li><li>O(n) - 线性空间：与输入规模成正比。</li><li>O(n^2) - 二次空间：需要二维存储，例如矩阵操作。</li></ol><h3 id="算法优化" tabindex="-1"><a class="header-anchor" href="#算法优化" aria-hidden="true">#</a> 算法优化</h3><ol><li>时间复杂度优化</li></ol><ul><li>使用合适的数据结构（如哈希表、优先队列）。</li><li>改进算法逻辑（如动态规划代替递归）。</li><li>降低循环层数，优化条件判断。</li></ul><ol start="2"><li>空间复杂度优化</li></ol><ul><li>原地操作减少额外空间需求。</li><li>使用懒加载或流式处理避免整体存储。</li></ul><h2 id="常见排序算法与实现" tabindex="-1"><a class="header-anchor" href="#常见排序算法与实现" aria-hidden="true">#</a> 常见排序算法与实现</h2><p>Todoist</p>',30);function x(b,k){const i=r("ExternalLinkIcon");return t(),n("div",null,[h,c,l("ul",null,[l("li",null,[l("a",u,[e("Algorithm Visualizer"),o(i)])]),l("li",null,[l("a",_,[e("Visual go"),o(i)])]),l("li",null,[l("a",p,[e("LeetCode"),o(i)])])]),f])}const g=a(d,[["render",x],["__file","index.html.vue"]]);export{g as default};
