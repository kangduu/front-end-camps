const e=JSON.parse('{"key":"v-76b80b4d","path":"/posts/javascript/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.html","title":"Javascript内存泄漏","lang":"zh-CN","frontmatter":{"title":"Javascript内存泄漏","category":"javascript","description":"内存泄漏 ​\\t内存泄漏指的是：任何对象在你不再拥有或不再需要之后任然存在。 不再拥有——（无法获取） 不再需要——（任存在隐藏的引用） 常见的内存泄漏 闭包 控制台日志 循环（两对象彼此引用且彼此保留） 事件监听，addEventListener需要removeEventListener移除（传递给两者的函数必须一致） setTimeout/setInterval ，对应的使用clearTimeout/clearInterval清空 注意，使用setTimeout模拟setInterval 循环调用会造成内存泄漏 如Promise、rxjs的Observables、node的EventEmitters这些方法，无回调函数或未取消监听都会造成内存泄漏 Promise如果没有resolved或者rejected，会连同then()中的代码一起造成内存泄漏 在没有虚拟dom的计算下实现了无无限滚动，那么dom节点的数量将无限增加 IntersectionObserver, ResizeObserver, MutationObserver 这些新的事件监听Api，都必须使用对应的disconnect取消监听 同redux、vuex这样挂载在全局的状态管理，如果不注意内存的占用，则会持续增加不会被释放","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/front-end-camps/posts/javascript/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.html"}],["meta",{"property":"og:site_name","content":"前端集训营"}],["meta",{"property":"og:title","content":"Javascript内存泄漏"}],["meta",{"property":"og:description","content":"内存泄漏 ​\\t内存泄漏指的是：任何对象在你不再拥有或不再需要之后任然存在。 不再拥有——（无法获取） 不再需要——（任存在隐藏的引用） 常见的内存泄漏 闭包 控制台日志 循环（两对象彼此引用且彼此保留） 事件监听，addEventListener需要removeEventListener移除（传递给两者的函数必须一致） setTimeout/setInterval ，对应的使用clearTimeout/clearInterval清空 注意，使用setTimeout模拟setInterval 循环调用会造成内存泄漏 如Promise、rxjs的Observables、node的EventEmitters这些方法，无回调函数或未取消监听都会造成内存泄漏 Promise如果没有resolved或者rejected，会连同then()中的代码一起造成内存泄漏 在没有虚拟dom的计算下实现了无无限滚动，那么dom节点的数量将无限增加 IntersectionObserver, ResizeObserver, MutationObserver 这些新的事件监听Api，都必须使用对应的disconnect取消监听 同redux、vuex这样挂载在全局的状态管理，如果不注意内存的占用，则会持续增加不会被释放"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-09-11T14:13:31.000Z"}],["meta",{"property":"article:author","content":"kangduu"}],["meta",{"property":"article:modified_time","content":"2023-09-11T14:13:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Javascript内存泄漏\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-09-11T14:13:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kangduu\\",\\"url\\":\\"https://github.com/kangduu\\"}]}"]]},"headers":[{"level":2,"title":"内存泄漏","slug":"内存泄漏","link":"#内存泄漏","children":[]},{"level":2,"title":"常见的内存泄漏","slug":"常见的内存泄漏","link":"#常见的内存泄漏","children":[{"level":3,"title":"容易引起内存使用不当的场景","slug":"容易引起内存使用不当的场景","link":"#容易引起内存使用不当的场景","children":[]}]},{"level":2,"title":"拓展阅读","slug":"拓展阅读","link":"#拓展阅读","children":[{"level":3,"title":"V8引擎","slug":"v8引擎","link":"#v8引擎","children":[]},{"level":3,"title":"如何查看内存","slug":"如何查看内存","link":"#如何查看内存","children":[]},{"level":3,"title":"QA","slug":"qa","link":"#qa","children":[]}]}],"git":{"createdTime":1694161545000,"updatedTime":1694441611000,"contributors":[{"name":"dukang","email":"dk@nosugartech.com","commits":1},{"name":"kangduu","email":"dukang1127@163.com","commits":1}]},"readingTime":{"minutes":2.6,"words":779},"filePathRelative":"posts/javascript/内存泄漏.md","localizedDate":"2023年9月8日","excerpt":"<h2> 内存泄漏</h2>\\n<p>​\\t内存泄漏指的是：<strong>任何对象在你不再拥有或不再需要之后任然存在</strong>。</p>\\n<ul>\\n<li>不再拥有——（无法获取）</li>\\n<li>不再需要——（任存在隐藏的引用）</li>\\n</ul>\\n<h2> 常见的内存泄漏</h2>\\n<ol>\\n<li>闭包</li>\\n<li>控制台日志</li>\\n<li>循环（两对象彼此引用且彼此保留）</li>\\n<li>事件监听，addEventListener需要removeEventListener移除（<strong>传递给两者的函数必须一致</strong>）</li>\\n<li>setTimeout/setInterval ，对应的使用clearTimeout/clearInterval清空</li>\\n<li><strong>注意，使用setTimeout模拟setInterval 循环调用会造成内存泄漏</strong></li>\\n<li>如Promise、rxjs的Observables、node的EventEmitters这些方法，无回调函数或未取消监听都会造成内存泄漏</li>\\n<li>Promise如果没有resolved或者rejected，会连同then()中的代码一起造成内存泄漏</li>\\n<li>在没有虚拟dom的计算下实现了无无限滚动，那么dom节点的数量将无限增加</li>\\n<li><a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">IntersectionObserver</a>, <a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">ResizeObserver</a>, <a href=\\"https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">MutationObserver</a> 这些新的事件监听Api，都必须使用对应的disconnect取消监听</li>\\n<li>同redux、vuex这样<strong>挂载在全局的状态管理，如果不注意内存的占用，则会持续增加不会被释放</strong></li>\\n</ol>","autoDesc":true}');export{e as data};
